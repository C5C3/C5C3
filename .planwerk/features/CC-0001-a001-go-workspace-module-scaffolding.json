{
  "feature_id": "CC-0001",
  "title": "A001: Go Workspace & Module Scaffolding",
  "slug": "a001-go-workspace-module-scaffolding",
  "status": "proposed",
  "phase": null,
  "summary": "",
  "description": "**Size:** ðŸ—ï¸ large\n**Category:** infrastructure\n**Priority:** critical\n\n## Open Questions\n\nAll questions resolved â€” user decisions incorporated below.\n\n## Summary\n\nScaffold the foundational Go workspace and module structure for the CobaltCore monorepo. This creates `go.work` with three modules (`internal/common`, `operators/keystone`, `operators/c5c3`), initializes `go.mod` per module with controller-runtime/apimachinery dependencies, scaffolds minimal `main.go` entrypoints for both operators (manager setup, scheme registration, leader election, health probes), and provides the top-level `Makefile` and `golangci-lint` configuration. This is S001 from the implementation plan â€” the base layer upon which all subsequent features (S002â€“S026) build.\n\n## Scope\n\n**Included:**\n- `go.work` with `use` directives for 3 modules (Go 1.24 â€” user decision, deviates from docs which say 1.23)\n- Directory tree: `internal/common/`, `operators/keystone/`, `operators/c5c3/`, `images/`, `releases/`, `deploy/`, `tests/e2e/` â€” placeholder dirs get `.gitkeep`\n- `go.mod` for each module with `controller-runtime v0.19+`, `k8s.io/apimachinery v0.31+`, `k8s.io/client-go v0.31+`\n- `replace` directives in operator `go.mod` files for `internal/common` (CI builds without `go.work`)\n- `main.go` for `operators/keystone` and `operators/c5c3` with: scheme registration (runtime + k8s core schemes), `ctrl.NewManager`, leader election (`--leader-elect` flag), health/readiness probes (`/healthz`, `/readyz`), metrics bind address, controller registration stub (no-op comment until reconcilers exist)\n- Top-level `Makefile` with targets: `generate`, `manifests`, `build`, `test`, `test-integration`, `lint`, `docker-build`, `helm-package`, `e2e`, `deploy-infra` (stub), `install-test-deps` (stub) â€” with `OPERATOR` variable for targeting individual operators\n- `.golangci.yml` with standard linters and exclusions for generated code (`zz_generated.*`)\n- `internal/common/doc.go` â€” package doc placeholder so the module compiles\n- `go.sum` files generated via `go mod tidy`\n\n**Excluded (with rationale):**\n- CRD type definitions, `api/v1alpha1/` â€” S011, YAGNI until reconciler work starts\n- Controller/reconciler implementations â€” S013\n- Shared library packages (`internal/common/conditions/`, `config/`, etc.) â€” S004, S005\n- Helm chart scaffolding â€” S017\n- Dockerfiles in `images/` â€” S006\n- GitHub Actions CI workflows â€” S003\n- Test suites (envtest setup, Chainsaw tests) â€” S002, S012, S014\n- Webhook configuration â€” S011, no types exist yet\n- Kubebuilder `config/` directories (crd, rbac, manager manifests) â€” S011\n- Operator SDK scaffolding (`operator-sdk init`) â€” creates too many files we'd delete; hand-crafted `main.go` matches documented patterns better\n\n## Visualization\n\n```mermaid\nflowchart TD\n    subgraph root[\"Repository Root\"]\n        gowork[\"go.work\"]\n        makefile[\"Makefile\"]\n        lint[\".golangci.yml\"]\n    end\n\n    subgraph common[\"internal/common/\"]\n        gomod_c[\"go.mod\"]\n        doc_c[\"doc.go\"]\n    end\n\n    subgraph keystone[\"operators/keystone/\"]\n        gomod_k[\"go.mod\"]\n        main_k[\"main.go\"]\n    end\n\n    subgraph c5c3[\"operators/c5c3/\"]\n        gomod_cc[\"go.mod\"]\n        main_cc[\"main.go\"]\n    end\n\n    subgraph placeholders[\"Placeholder Directories\"]\n        images[\"images/.gitkeep\"]\n        releases[\"releases/.gitkeep\"]\n        deploy[\"deploy/.gitkeep\"]\n        tests[\"tests/e2e/.gitkeep\"]\n    end\n\n    gowork -->|\"use ./internal/common\"| common\n    gowork -->|\"use ./operators/keystone\"| keystone\n    gowork -->|\"use ./operators/c5c3\"| c5c3\n\n    gomod_k -->|\"require + replace\"| gomod_c\n    gomod_cc -->|\"require + replace\"| gomod_c\n\n    main_k -->|\"ctrl.NewManager\"| CR[\"controller-runtime\"]\n    main_cc -->|\"ctrl.NewManager\"| CR\n\n    makefile -->|\"iterates OPERATOR\"| keystone\n    makefile -->|\"iterates OPERATOR\"| c5c3\n    lint -->|\"applies to all modules\"| common\n```\n\n```mermaid\nflowchart LR\n    subgraph main_go[\"main.go Structure\"]\n        A[\"Register Schemes\"] --> B[\"Create Manager\"]\n        B --> C[\"Enable Leader Election\"]\n        C --> D[\"Setup Health Probes\"]\n        D --> E[\"Controller Stub\"]\n        E --> F[\"mgr.Start\"]\n    end\n```\n\n## Key Components\n\n- **`go.work`** â€” Workspace root linking 3 modules; Go 1.24; enables local resolution of `internal/common`\n- **`internal/common/go.mod`** â€” Shared library module (`github.com/c5c3/c5c3/internal/common`); minimal deps (apimachinery, controller-runtime for types only); `doc.go` placeholder so the module compiles\n- **`operators/keystone/go.mod`** â€” Module `github.com/c5c3/c5c3/operators/keystone`; full controller-runtime + client-go deps; `replace` directive for `internal/common` per docs (`docs/09-implementation/01-project-setup.md:112-126`)\n- **`operators/c5c3/go.mod`** â€” Module `github.com/c5c3/c5c3/operators/c5c3`; same dependency pattern as keystone\n- **`operators/*/main.go`** â€” Entrypoints with: scheme registration (runtime scheme + k8s core), `ctrl.NewManager(...)`, `--leader-elect` flag, health probe endpoints (`/healthz`, `/readyz`), metrics bind address (`:8080`), `// TODO: register controllers here` stub, `mgr.Start(ctrl.SetupSignalHandler())`\n- **`Makefile`** â€” Multi-operator build orchestration; `OPERATOR` variable to target individual operators (per docs `docs/09-implementation/01-project-setup.md:146-152`); `OPERATORS` list defaults to `keystone c5c3`; `deploy-infra` and `install-test-deps` as stubs; all 11 requested targets\n- **`.golangci.yml`** â€” Enables `govet`, `errcheck`, `staticcheck`, `unused`, `gosimple`, `ineffassign`, `typecheck`, `gocritic`; excludes `zz_generated*.go`; Go 1.24 target\n- **Placeholder dirs** â€” `images/`, `releases/`, `deploy/`, `tests/e2e/` with `.gitkeep` for future S003/S006/S002 work\n\n## Deviation Note\n\nThe user chose **Go 1.24** over the documented Go 1.23 (`docs/09-implementation/01-project-setup.md:11,158`). All `go.work` and `go.mod` files will use `go 1.24`. The docs should be updated separately to reflect this decision.",
  "stories": [],
  "requirements": [],
  "tasks": [],
  "test_specifications": [],
  "affected_files": [],
  "similar_patterns": [],
  "review_criteria": [],
  "implementation_notes": "",
  "status_history": {
    "draft": {
      "github_account": "berendt",
      "timestamp": "2026-02-22T20:42:36.260667"
    },
    "elaborated": {
      "github_account": "berendt",
      "timestamp": "2026-02-22T20:47:31.662298"
    }
  },
  "origin": "plan",
  "devils_advocate_report": {
    "verdict": "RECONSIDER",
    "summary": "The proposal is structurally sound and well-scoped for a foundational scaffolding step, but contains a critical module path error and several medium-risk design choices that warrant correction before implementation. The exclusion boundaries are well-reasoned and the YAGNI discipline is commendable. However, the elaboration has been copy-pasted three times identically (summary, scope, key components appear verbatim in proposal and elaboration sections), which suggests insufficient refinement between drafting rounds.",
    "challenges": [
      {
        "claim": "Module paths use `github.com/c5c3/c5c3` (e.g., `github.com/c5c3/c5c3/internal/common`, `github.com/c5c3/c5c3/operators/keystone`)",
        "counter_argument": "The documentation at `docs/09-implementation/01-project-setup.md` consistently uses `github.com/cobaltcore-dev/cobaltcore` as the module path prefix. The `.planwerk/settings.toml` confirms `repository = \"cobaltcore-dev/cobaltcore\"`. Using `c5c3/c5c3` would create a module path that doesn't match the actual GitHub organization/repo, breaking `go get`, breaking the replace directives, and creating a permanent naming mismatch that's painful to fix after downstream features depend on it.",
        "risk_level": "high",
        "alternative": "Use `github.com/cobaltcore-dev/cobaltcore` as the module path prefix throughout, matching the documented convention exactly. This is not optional â€” it's a bug in the elaboration."
      },
      {
        "claim": "Go 1.24 is the right choice, deviating from the documented Go 1.23",
        "counter_argument": "Go 1.24 was released February 2025. By now (Feb 2026), it's a reasonable choice and likely what CI environments support. However, the proposal doesn't verify that controller-runtime v0.19.x and client-go v0.31.x are compatible with Go 1.24. Controller-runtime v0.19 was built against the Kubernetes 1.31 release cycle which targeted Go 1.22/1.23. While Go is generally backward-compatible, there have been cases where newer Go versions expose latent issues in dependency code (e.g., `loopvar` semantics change in 1.22, `range-over-func` in 1.23). The risk is that `go mod tidy` fails or tests break due to incompatibility.",
        "risk_level": "medium",
        "alternative": "Option A: Stick with Go 1.24 but bump dependencies to controller-runtime v0.20+ / client-go v0.32+ which would have been built against Go 1.24. Option B: Keep Go 1.24 but verify compatibility as an explicit implementation step before committing. Option C: Use Go 1.23 as documented and defer the version bump to a separate PR that also updates the docs. The cleanest path is Option A if those versions exist and are stable."
      },
      {
        "claim": "Hand-crafted `main.go` is better than `operator-sdk init` because it \"creates too many files we'd delete\"",
        "counter_argument": "This is a reasonable position â€” acknowledged as genuinely strong. However, the counter-risk is that hand-crafted `main.go` files miss subtle best practices that the SDK scaffolding includes: proper signal handling edge cases, correct scheme registration ordering, PProf endpoints, secure metrics serving (controller-runtime v0.19+ added `SecureServing` for metrics). A hand-crafted main.go is a maintenance liability if the team isn't deeply familiar with controller-runtime internals. The proposal's main.go description mentions metrics on `:8080` but doesn't mention whether this is plaintext or TLS â€” controller-runtime v0.19 deprecated insecure metrics serving.",
        "risk_level": "medium",
        "alternative": "Use controller-runtime's `metricsserver.Options` struct with `SecureServing: true` (or at minimum `BindAddress: \"0\"` to disable if not needed yet). Reference the upstream scaffolding from kubebuilder v4 for the exact manager options pattern rather than inventing from scratch. The key files to reference are kubebuilder's `cmd/main.go` template."
      },
      {
        "claim": "11 Makefile targets should all be created now, with stubs for targets like `deploy-infra`, `install-test-deps`, `docker-build`, `helm-package`, `e2e`",
        "counter_argument": "Creating 6+ stub targets that do nothing (or echo a message) is pure ceremony. Stubs have a cost: they give a false sense of completeness, they make `make help` output misleading, and they'll need to be found and filled in later across multiple future features (S002, S003, S006, S017). If someone runs `make docker-build` and it silently succeeds with no output, they may think it worked. YAGNI applies to Makefile targets too â€” the proposal correctly applies YAGNI to CRDs and controllers but inconsistently applies it to build targets.",
        "risk_level": "low",
        "alternative": "Only create targets that do real work today: `build`, `test`, `lint`, `generate`, `manifests`. For the rest, add them in the features that implement them (S002 adds `test-integration`/`e2e`/`install-test-deps`, S006 adds `docker-build`, S017 adds `helm-package`). This keeps the Makefile honest and avoids dead code. If the docs mandate all 11 targets in S001, add them but make stubs fail explicitly with `$(error \"Not implemented â€” see S0XX\")` rather than silently succeeding."
      },
      {
        "claim": "`internal/common` needs only a `doc.go` placeholder to compile",
        "counter_argument": "This is correct â€” a package needs at least one `.go` file. However, `doc.go` as a pattern creates a module that's importable but exports nothing. The operator `go.mod` files will `require` this module and the `replace` directives will point to it. But since no operator code actually imports any package from `internal/common`, `go mod tidy` will remove the require directive and the replace directive becomes orphaned (go mod tidy removes unused replaces in Go 1.24). This means the carefully documented replace directives won't survive `go mod tidy`.",
        "risk_level": "medium",
        "alternative": "Option A: Don't add `internal/common` as a dependency in operator `go.mod` files until S004/S005 when actual shared code exists. The `go.work` file handles local resolution regardless. Option B: Add a trivial exported symbol in `internal/common` and a trivial import in each operator's `main.go` to keep the dependency alive through `go mod tidy`. Option A is cleaner â€” the replace directives are only needed when there's an actual dependency."
      },
      {
        "claim": "The `OPERATOR` variable pattern for the Makefile targets individual operators",
        "counter_argument": "The proposal describes both `OPERATOR` (singular, for targeting one) and `OPERATORS` (plural, defaulting to `keystone c5c3`). This dual-variable pattern is a common source of confusion. Does `make build OPERATOR=keystone` override `OPERATORS`? What if someone sets both? The Makefile logic to handle `ifdef OPERATOR` vs iteration over `OPERATORS` needs careful implementation. A subtle bug here means `make build` builds nothing or builds the wrong thing silently.",
        "risk_level": "low",
        "alternative": "Simplify: use only `OPERATORS` (plural). `make build OPERATORS=keystone` works fine for single targeting. One variable, one pattern, no ambiguity. If the docs mandate `OPERATOR` singular, implement it as: `ifdef OPERATOR; OPERATORS := $(OPERATOR); endif` at the top of the Makefile, documented with a comment."
      },
      {
        "claim": "controller-runtime v0.19+ and k8s.io/apimachinery v0.31+ are the right dependency versions",
        "counter_argument": "These versions are from mid-2024 (Kubernetes 1.31 cycle). By February 2026, Kubernetes is likely on 1.33 or 1.34, with controller-runtime at v0.21+. Starting a new project on 18-month-old dependencies means: (1) missing security patches, (2) missing API improvements, (3) needing a dependency bump PR shortly after scaffolding, (4) the version might not even support Go 1.24 properly. The docs were written when these were current; they aren't anymore.",
        "risk_level": "medium",
        "alternative": "Use the latest stable controller-runtime and matching k8s.io/* libraries. If the docs say v0.19/v0.31, update the docs as part of this PR (the deviation note already acknowledges doc updates are needed for Go version â€” extend this to deps). Alternatively, pin to whatever version is current and note in the PR that docs need updating."
      },
      {
        "claim": "The scope boundaries between S001 and subsequent features (S002-S026) are clear and correct",
        "counter_argument": "This is genuinely well-done â€” the exclusion list with rationale is one of the strongest parts of the proposal. The one gap: the proposal doesn't mention `.gitignore` updates. The existing `.gitignore` may need additions for Go workspace artifacts (`go.work.sum`), build output directories specific to this project's structure, or IDE files for Go development. This is a minor omission but belongs in S001 since it's foundational.",
        "risk_level": "low",
        "alternative": "Add `.gitignore` review/updates to the scope. Specifically ensure `go.work.sum` handling is intentional (it should typically be committed but some teams `.gitignore` it)."
      }
    ],
    "risk_flags": [
      "CRITICAL: Module path `github.com/c5c3/c5c3` is wrong â€” must be `github.com/cobaltcore-dev/cobaltcore` per all project documentation and settings. If implemented as written, every subsequent feature will build on the wrong module path, requiring a painful rename across all imports, go.mod files, and replace directives.",
      "MEDIUM: `go mod tidy` with Go 1.24 will strip unused `require`/`replace` directives for `internal/common` since nothing actually imports it yet. The elaboration's claim that replace directives will exist after `go mod tidy` is likely incorrect.",
      "MEDIUM: Dependency versions (controller-runtime v0.19, client-go v0.31) are ~18 months old and may not be compatible with Go 1.24. The `go mod tidy` step could fail or produce warnings."
    ],
    "alternatives": [
      "**Phased Makefile approach**: Only implement targets that work today (`build`, `test`, `lint`). Add `generate` and `manifests` as no-ops since there are no generators yet. Defer `docker-build`, `helm-package`, `e2e`, `deploy-infra`, `install-test-deps` to their respective features. Trade-off: slightly more PRs touch the Makefile, but each target works when added. Avoids dead code and false confidence.",
      "**Defer `internal/common` dependency wiring**: Create the module and `doc.go`, but don't add it to operator `go.mod` files. The `go.work` file provides local resolution. Add the `require` + `replace` directives in S004/S005 when actual shared code exists and imports are real. Trade-off: the replace directives aren't tested until S004, but they're trivial and well-documented. Avoids `go mod tidy` stripping them immediately.",
      "**Use latest controller-runtime**: Instead of v0.19/v0.31, use whatever is current (likely v0.21+/v0.33+). Trade-off: deviates further from docs, but the docs already need updating for Go 1.24. Better to start with current deps than immediately need a bump. Update docs in the same PR."
    ]
  }
}
